= Clara Rules: Rete Engine Architecture & Optimizations
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: rouge

== Overview

Clara Rules implements the **Rete algorithm** for forward-chaining rule evaluation in Clojure and ClojureScript.
This document describes the engine's internal architecture and the optimizations applied (and proposed) to improve throughput and reduce allocation pressure.

The engine is cross-platform (`.cljc`), with the compiler (`compiler.clj`) being CLJ-only.
Key source files:

[cols="1,3"]
|===
|File |Role

|`engine.cljc`
|Core Rete network: node types, session, fire-rules loop

|`memory.cljc`
|Working memory protocols and transient/persistent implementations

|`compiler.clj`
|Compiles `defrule`/`defquery` forms into the Rete node graph

|`accumulators.cljc`
|Built-in accumulators (min, max, sum, count, all, distinct)

|`update_cache/core.cljc`
|Batched update cache used during rule firing

|`listener.cljc`
|Event listener protocol for tracing and debugging
|===

== Rete Network Architecture

The Rete network has two phases: the **alpha network** filters individual facts by type and constraint, and the **beta network** joins across multiple conditions.

=== High-Level Data Flow

....
              insert(facts)
                  │
                  ▼
     ┌────────────────────────┐
     │      Alpha Network     │
     │                        │
     │  fact-type-fn dispatch │──── groups facts by type (default: Java class)
     │          │              │
     │          ▼              │
     │    ┌───────────┐       │
     │    │ AlphaNode │ ×N    │──── each node tests one condition
     │    │           │       │     activation fn: (fact, env) → bindings | nil
     │    └─────┬─────┘       │
     │          │              │
     │          ▼              │
     │   Element(fact, binds)  │──── matched facts wrapped as Elements
     └────────────┬───────────┘
                  │
                  ▼
     ┌────────────────────────┐
     │      Beta Network      │
     │                        │
     │  Tokens flow left ───► │     Elements arrive from right
     │                        │
     │  ┌──────────────────┐  │
     │  │  RootJoinNode    │  │──── entry point: converts Elements → Tokens
     │  └────────┬─────────┘  │
     │           │             │
     │  ┌────────▼─────────┐  │
     │  │  HashJoinNode /  │  │──── joins on binding keys (equality)
     │  │  ExprJoinNode    │  │     or arbitrary join-filter-fn
     │  └────────┬─────────┘  │
     │           │             │
     │  ┌────────▼─────────┐  │
     │  │  NegationNode /  │  │──── :not conditions
     │  │  AccumulateNode  │  │     :accum conditions
     │  │  TestNode        │  │     :test conditions
     │  └────────┬─────────┘  │
     │           │             │
     │  ┌────────▼─────────┐  │
     │  │ ProductionNode / │  │──── terminal nodes
     │  │ QueryNode        │  │     rules fire; queries collect results
     │  └──────────────────┘  │
     └────────────────────────┘
....

=== Core Data Structures

[source,clojure]
----
;; A fact that passed alpha-node filtering, paired with extracted bindings
(defrecord Element [fact bindings])

;; A partial match flowing through the beta network
(defrecord Token [matches   ;; vec of [fact, node-id] pairs
                  bindings]) ;; map of ?var → value

;; A rule ready to fire
(defrecord Activation [node token])

;; Root token — empty match at network entry
(def empty-token (->Token [] {}))
----

=== Alpha Network Detail

The alpha network is organized by **fact type** (determined by `fact-type-fn`, which defaults to `type`/Java class).
When facts are inserted, `get-alphas-fn` maps each fact to its matching alpha-node roots.

....
  Facts: [TempReading{:value 110}, Order{:total 50}]
         │
         ▼
  get-alphas-fn (fact-type dispatch)
         │
         ├── TempReading ──► AlphaNode-1 (activation: :value > 100?)
         │                       │
         │                       ├─ match → Element{TempReading, {?temp 110}}
         │                       │              │
         │                       │              ▼ (send-elements to beta children)
         │                       │
         │                       └─ AlphaNode-2 (activation: :value > 150?)
         │                              └─ no match (nil bindings)
         │
         └── Order ──────── AlphaNode-3 (activation: always true)
                                │
                                └─ match → Element{Order, {?order <Order>}}
....

Each `AlphaNode` record contains:

* `id` — unique node identifier
* `env` — captured environment (closed-over variables from rule compilation)
* `activation` — compiled condition function `(fn [fact env] bindings-or-nil)`
* `children` — downstream beta nodes
* `fact-type` — the type this node filters

=== Beta Network Detail

Beta nodes receive **Tokens from the left** (upstream beta nodes) and **Elements from the right** (alpha nodes).
Join nodes combine them; terminal nodes consume them.

==== Node Type Reference

[cols="2,1,1,3"]
|===
|Node |Left |Right |Purpose

|`RootJoinNode`
|✓
|✓
|Entry point. Converts Elements into initial Tokens.

|`HashJoinNode`
|✓
|✓
|Equality join on `binding-keys`. Cross-product of matching tokens × elements.

|`ExpressionJoinNode`
|✓
|✓
|Join with arbitrary `join-filter-fn` predicate. Used when join cannot be expressed as simple equality.

|`NegationNode`
|✓
|✓
|Passes tokens only when _no_ matching elements exist. Implements `:not` conditions.

|`NegationWithJoinFilterNode`
|✓
|✓
|`:not` with a `join-filter-fn` applied per token-element pair.

|`TestNode`
|✓
|—
|Stateless boolean filter on tokens. Implements `:test` conditions.

|`AccumulateNode`
|✓
|✓
|Aggregates elements (sum, count, min, max, etc.) and binds result.

|`AccumulateWithJoinFilterNode`
|✓
|✓
|Accumulation with per-element join filtering.

|`ProductionNode`
|✓
|—
|Terminal. Creates `Activation` records for rule RHS execution.

|`QueryNode`
|✓
|—
|Terminal. Stores matching tokens for query retrieval.
|===

==== Join Node Cross-Product

The fundamental operation at a join node is the **cross-product** of stored tokens and incoming elements (or vice versa).
For `HashJoinNode`, elements and tokens are indexed by `binding-keys` so only compatible pairs are combined:

....
  left-activate(tokens):                right-activate(elements):

    store tokens in β-memory              store elements in α-memory
           │                                      │
           ▼                                      ▼
    lookup elements by                     lookup tokens by
    join-bindings                          join-bindings
           │                                      │
           ▼                                      ▼
    for each (token × element):            for each (token × element):
      new-token = Token(                     new-token = Token(
        matches ++ [fact, node-id],            matches ++ [fact, node-id],
        bindings ∪ element-bindings)           bindings ∪ element-bindings)
           │                                      │
           ▼                                      ▼
    send-tokens to children                send-tokens to children
....

=== Memory Model

Working memory uses two representations:

* **`PersistentLocalMemory`** — immutable snapshot, held by the session between `fire-rules` calls
* **`TransientLocalMemory`** — mutable, used within a single `fire-rules` invocation for performance

....
  TransientLocalMemory
  ├── alpha-memory:      {node-id → {bindings → [Element ...]}}
  ├── beta-memory:       {node-id → {bindings → [Token ...]}}
  ├── accum-memory:      {node-id → {join-bindings → {fact-bindings → result}}}
  ├── production-memory: {node-id → {token → [inserted-facts]}}
  └── activation-map:    {group-key → PriorityQueue<Activation>}
....

The activation queue is organized by **activation groups** (salience/priority).
Within a group, activations are ordered by rule definition order.

=== Session & fire-rules

Sessions (`LocalSession`) are **immutable values**.
`insert`/`retract` return new sessions with queued `PendingUpdate` operations.
`fire-rules` processes them:

....
  fire-rules(session)
      │
      ▼
  1. to-transient(memory)
      │
      ▼
  2. Process pending operations
     ├── insertions: alpha-activate each fact through alpha roots
     └── retractions: alpha-retract each fact through alpha roots
      │
      ▼
  3. fire-rules* loop ◄───────────────────────────────┐
      │                                                │
      ├── pop-activation! from highest-priority group  │
      │         │                                      │
      │         ▼                                      │
      │    Execute rule RHS:                           │
      │      ((:rhs node) token env)                   │
      │         │                                      │
      │         ├── collect batched insertions          │
      │         │   (logical & unconditional)           │
      │         ├── collect batched retractions         │
      │         │                                      │
      │         ▼                                      │
      │    flush-insertions! / flush-rhs-retractions!  │
      │         │                                      │
      │         └── propagate through network ─────────┘
      │                (may create new activations)
      │
      ├── On group transition: flush-updates
      │   (propagate batched alpha inserts/retracts)
      │
      └── No activations left?
            ├── flush-updates → new activations? loop ─┘
            └── no → done, to-persistent!(memory)
....

==== Truth Maintenance

* `insert!` (inside rule RHS) — **logical insertion**. The engine tracks which rule/token produced each fact.
  If the rule's conditions later become false, the inserted facts are automatically retracted.
* `insert-unconditional!` — persists regardless of rule truth.
* Retractions cascade transitively: retracting a fact may invalidate rules, which retracts their logical insertions, which may invalidate further rules.

== Implemented Optimizations

=== 1.1 — `drop-one-of` Vector Optimization

**File:** `accumulators.cljc` | **Impact:** Reduced allocation in accumulator retraction

The `all` accumulator collects matching facts into a vector.
On retraction, one instance of the retracted fact must be removed.
The original implementation used lazy sequence operations (`take-while` / `drop-while`), which allocate intermediate seqs even for the common case of vector collections.

.Before
[source,clojure]
----
(defn- drop-one-of [items value]
  (let [pred #(not= value %)]
    (into (empty items) cat
      [(take-while pred items)
       (rest (drop-while pred items))])))
----

.After
[source,clojure]
----
(defn- drop-one-of [items value]
  (if (vector? items)
    (let [n (count items)
          idx (loop [i 0]
                (cond
                  (>= i n) -1
                  (= value (items i)) i
                  :else (recur (inc i))))]
      (if (neg? idx)
        items
        (into (subvec items 0 idx) (subvec items (inc idx)))))
    ;; Non-vector fallback
    (let [pred #(not= value %)]
      (into (empty items) cat
        [(take-while pred items)
         (rest (drop-while pred items))]))))
----

The vector path uses `subvec` (O(1) view creation) and a single `into` to concatenate, avoiding lazy seq machinery entirely.

=== 1.2 — `do-accumulate` 3-Arity (Avoid Record Allocation)

**File:** `engine.cljc` | **Impact:** Eliminated per-accumulation `Accumulator` record allocation

When accumulating over new facts with a known previous result, the engine previously created a new `Accumulator` record via `(assoc accumulator :initial-value previous-result)` just to pass the initial value.
A 3-arity `do-accumulate` accepts the initial value directly:

[source,clojure]
----
(defn- do-accumulate
  "Two-arity uses the accumulator's initial-value;
   three-arity uses the provided initial value
   to avoid allocating a new Accumulator record."
  ([accumulator facts]
   (r/reduce (:reduce-fn accumulator)
             (:initial-value accumulator)
             facts))
  ([accumulator initial-value facts]
   (r/reduce (:reduce-fn accumulator)
             initial-value
             facts)))
----

Call sites in `AccumulateNode` and `AccumulateWithJoinFilterNode` now pass the previous result directly instead of allocating a modified record.

=== 1.3 — Listener Null-Check Short-Circuit

**File:** `engine.cljc` | **Impact:** Eliminated allocation and protocol dispatch when no listener is attached

Most production sessions run without a tracing listener.
Before this optimization, `AlphaNode.alpha-activate` always evaluated `(map first fact-binding-pairs)` to pass to the listener, even when no listener was present.

[source,clojure]
----
;; AlphaNode.alpha-activate — guarded listener call
(when-not (l/null-listener? listener)
  (l/alpha-activate! listener node (map first fact-binding-pairs)))
----

The `null-listener?` check is O(1) and avoids:

* Allocating a lazy seq via `(map first ...)`
* Protocol dispatch on the no-op listener
* Same pattern applied to `alpha-retract` and `retract-facts-loop`

=== 2.1 — Join Node Unlinking

**File:** `engine.cljc` | **Impact:** Eliminated empty cross-products

When a join node is activated from one side but no data exists on the other side, the cross-product is vacuously empty.
Previously the engine would still enter the `eager-for` comprehension, allocate an empty result, and call `send-tokens`.
Now a `when-let` guard short-circuits:

[source,clojure]
----
;; HashJoinNode.left-activate
(mem/add-tokens! memory node join-bindings tokens)
(l/left-activate! listener node tokens)
;; Short-circuit: skip cross-product when no elements exist
(when-let [elements (seq (mem/get-elements memory node join-bindings))]
  (send-tokens transport memory listener children
    (platform/eager-for [element elements, token tokens ...]
      (->Token ...))))
----

Applied to all four methods on `HashJoinNode` (`left-activate`, `left-retract`, `right-activate`, `right-retract`) and the corresponding methods on `ExpressionJoinNode`.

This is especially impactful in sparse networks where many nodes exist but few are active simultaneously.

=== 2.2 — Alpha Discrimination Tree

**Files:** `compiler.clj`, `engine.cljc` | **Impact:** Hash-based dispatch for equality constraints

When multiple alpha nodes share a fact type and have equality constraints on the same field with constant values, `DiscriminationNode` uses a hash map to dispatch only to matching entries instead of evaluating all N activation functions per fact.

....
  Facts of type Temperature
              │
              ▼
    DiscriminationNode (field :location)
         │ hash lookup on (:location fact)
         │
         ├── "kitchen" ──► AlphaNode-A (activation fn)
         │                     │
         │                     └─ Element → beta children
         │
         ├── "garage" ──► AlphaNode-B, AlphaNode-C
         │
         └── (no match) ──► skip, no activation calls
....

The discrimination metadata is extracted at compile time in `compiler.clj` by analyzing alpha-node activation functions for top-level equality tests on constant values.
Falls back to `FusedAlphaNode` when discrimination metadata is absent (e.g., deserialized sessions via durability).

=== 2.3 — OrderedUpdateCache Mutable Collections

**File:** `update_cache/core.cljc` | **Impact:** Removed atom CAS overhead in fire-rules loop

The `OrderedUpdateCache` batches insertions and retractions during rule firing before flushing them to the alpha network.
The original implementation used an `atom` with persistent vectors, incurring compare-and-swap overhead on every update — unnecessary since `fire-rules*` is single-threaded.

.CLJ — ArrayList
[source,clojure]
----
(deftype OrderedUpdateCache [^:unsynchronized-mutable ^ArrayList updates]
  UpdateCache
  (add-insertions! [this facts]
    (.add updates (->PendingUpdate :insert facts)))
  (add-retractions! [this facts]
    (.add updates (->PendingUpdate :retract facts)))
  (get-updates-and-reset! [this]
    (let [current-updates (Collections/unmodifiableList updates)]
      (set! updates (ArrayList.))
      (partition-by :type current-updates))))
----

.CLJS — mutable field with vector
[source,clojure]
----
(deftype OrderedUpdateCache [^:mutable updates]
  UpdateCache
  (add-insertions! [this facts]
    (set! updates (conj updates (->PendingUpdate :insert facts))))
  (add-retractions! [this facts]
    (set! updates (conj updates (->PendingUpdate :retract facts))))
  (get-updates-and-reset! [this]
    (let [current-updates updates]
      (set! updates [])
      (partition-by :type current-updates))))
----

This follows the precedent set by `CancellingUpdateCache`, which already used mutable Java collections.

=== 2.4 — Beta Sub-Indexing for ExpressionJoinNode

**Files:** `compiler.clj`, `engine.cljc` | **Impact:** Reduced cross-product from O(T×E) to O(T+E)

`ExpressionJoinNode` uses a `join-filter-fn` applied to every (token, element) pair.
When the filter contains equality sub-expressions (e.g., `(= (:id ?order) (:order-id fact))`), these are extracted at compile time and used as a hash index at runtime.

....
  Before:
    tokens × elements → filter each pair → O(T × E)

  After:
    build index: elements grouped by extracted key → O(E)
    for each token: lookup by key → O(T × E')
    where E' ≪ E when key is selective
....

At compile time (`compiler.clj`), top-level equalities in the join-filter expression are identified and key-extraction functions are generated.
At runtime, a local hash index is built from elements, and tokens look up only matching elements before applying the residual filter.

=== 2.5 — FusedAlphaNode for Batched Alpha Dispatch

**Files:** `rules.cljc`, `compiler.clj`, `engine.cljc` | **Impact:** Reduced per-fact dispatch overhead for multi-node types

When a fact type has N alpha nodes, `FusedAlphaNode` replaces N independent `alpha-activate` dispatches with a single per-fact-then-per-node pass.
It evaluates all activation functions in one loop, accumulates elements per original node, then batch-dispatches to beta children.

....
  Before (N alpha nodes for type T):
    for each alpha-node:
      alpha-activate(fact) → protocol dispatch → send-elements

  After (FusedAlphaNode):
    for each fact:
      for each activation-fn:
        if match → accumulate Element per target node
    for each target node with elements:
      batch send-elements to beta children
....

Fusion is applied at `get-alphas-fn` construction time (not stored in `alpha-roots`) to preserve durability serialization compatibility.
Single-node types are unchanged.

=== 2.6 — Allocation Reduction in Engine Hot Paths

**Files:** `engine.cljc`, `memory.cljc`, `platform.cljc`, `listener.cljc` | **Impact:** Significant reduction in per-activation and per-join allocation

Multiple targeted changes to reduce allocation pressure across the engine:

* **`eager-for` → `doseq` + transient:** Replace the `eager-for` macro with `doseq` + transient vector construction at ~26 call sites, eliminating lazy seq allocation
* **Atoms → volatiles:** Replace `atom` with `volatile!` in single-threaded `fire-rules*` paths (per-activation state, update tracking)
* **`RuleContext` defrecord:** Replace per-activation `{:node ... :token ...}` map allocation with a typed defrecord
* **Dynamic binding elimination:** Replace `*rule-context*` dynamic binding with a volatile field on `*current-session*`, eliminating `pushThreadBindings`/`popThreadBindings` per activation
* **`MapEntry` for match pairs:** Use `MapEntry` instead of `PersistentVector` for `[fact node-id]` pairs (~32 bytes vs ~96 bytes on JVM)
* **`flush-updates` optimization:** Eagerly group consecutive same-type updates into `[type facts]` pairs instead of lazy `partition-by` + `mapcat`
* **`select-keys` specialization:** Specialize 1-key and 2-key cases in `propagate-items-to-nodes` using map literals instead of generic `select-keys`
* **Memory path optimization:** Replace `get-in`/`assoc-in` with nested `get`/`assoc` in accumulator memory paths to eliminate key-path vector allocation
* **Eager sequence variants:** Replace lazy seqs with eager variants in `filter-accum-facts`, `pre-reduce`, `matches-some-facts?`, and `DelegatingListener` transitions
* **Join binding order fix:** Fix `conj` argument order in `HashJoinNode`/`ExpressionJoinNode` to iterate the smaller fact-bindings map

=== 2.7 — Collection-Oriented Batch Joins

**File:** `engine.cljc` | **Impact:** Reduced per-activation allocation in join node cross-products

==== 2.7.1 — Hoisting `match-pair` to element scope

In every cross-product loop, `(match-pair fact id)` previously appeared in the innermost body (token scope), allocating one `MapEntry` per `(token, element)` pair.
Since `match-pair` depends only on `element` (not `token`), it is now computed once per element with a `:let` binding at the element loop level, saving `(T - 1)` allocations per element group.

.Before (HashJoinNode.right-activate)
[source,clojure]
----
(platform/eager-for [token tokens
                     {:keys [fact bindings] :as element} elements]
                    (->Token (conj (:matches token) (match-pair fact id))
                             (conj (:bindings token) bindings)))
----

.After
[source,clojure]
----
(platform/eager-for [{:keys [fact bindings] :as element} elements
                     :let [mp (match-pair fact id)]
                     token tokens]
                    (->Token (conj (:matches token) mp)
                             (conj (:bindings token) bindings)))
----

Applied to all four methods on `HashJoinNode` and all eight paths in `ExpressionJoinNode`.

==== 2.7.2 — Single-element and single-token fast paths

The dominant real-world pattern is a single-fact insert (one element) activating T tokens, or a single new token joining E elements.
The general `eager-for` path allocates a volatile + transient vector even for this common case.

Fast paths use `mapv` or `keep` (via `into []`) directly, extracting element or token fields once:

.HashJoinNode.right-activate — single-element fast path
[source,clojure]
----
(if (next elements)
  ;; Multiple elements: hoist match-pair per element
  (platform/eager-for [{:keys [fact bindings] :as element} elements
                       :let [mp (match-pair fact id)]
                       token tokens]
                      (->Token (conj (:matches token) mp) ...))
  ;; Single element: extract once, mapv over tokens
  (let [{:keys [fact bindings]} (first elements)
        mp (match-pair fact id)]
    (mapv (fn [token] (->Token (conj (:matches token) mp) ...)) tokens)))
----

The `(next coll)` check is O(1) and avoids `count` allocation.
Symmetric fast paths are applied to `left-activate`, `left-retract`, and `right-retract` on both `HashJoinNode` and `ExpressionJoinNode`.

For `ExpressionJoinNode` with sub-indexing, the single-element path uses a linear scan over tokens (`= key (token-key-fn token)`) — for one element, this beats building a HashMap.

==== 2.7.3 — RootJoinNode: `mapv` instead of `eager-for`

`RootJoinNode` performs a 1:1 element → token transformation (no cross-product).
The `eager-for` macro's volatile + transient overhead is unnecessary here; `mapv` is used directly in both `right-activate` and `right-retract`.

==== 2.7.4 — Single-item fast path in `propagate-items-to-nodes`

When only one item is being propagated, `group-by-seq` previously allocated a `LinkedHashMap` and a `JavaEqualityWrapper` wrapper even for the trivial single-group case.
A `(next items)` guard skips `group-by-seq` entirely and calls `propagate-fn` directly:

[source,clojure]
----
(if (next items)
  (doseq [[join-bindings item-group] (platform/group-by-seq extract-fn items)]
    (propagate-fn node join-bindings item-group memory transport listener))
  (when-let [item (first items)]
    (propagate-fn node (extract-fn item) items memory transport listener)))
----


=== 2.8 — NegationWithJoinFilterNode Sub-Indexing

**Files:** `compiler.clj`, `engine.cljc` | **Impact:** Reduced O(T×E) → O(T+E) for `:not` conditions with join filters

`NegationWithJoinFilterNode` implements `:not` conditions that carry an arbitrary `join-filter-fn` (a predicate evaluated against each token–element pair).
The original implementation scanned all elements for every token — O(T×E) per activation.
Like the sub-indexing in 2.4, equality sub-expressions in the join filter are extracted at compile time to build a hash index at runtime.

At compile time (`compiler.clj`), top-level equalities in the `join-filter-expressions` are identified and two key-extraction functions are generated:

* `element-key-fn` — extracts a composite key from `(fact, element-bindings)` (fact side)
* `token-key-fn` — extracts the matching composite key from a token's bindings (token side)

At runtime, elements are grouped by `element-key-fn` into a local index.
Each token looks up only its matching candidate set via `token-key-fn` before applying the residual `join-filter-fn`.
Two runtime paths:

* **Batch path** (multiple elements): build `token-index` and `prev-element-index` once for all elements; use `mapcat` + `distinct` + `remove` to compute newly-blocked tokens in O(T+E)
* **Single-element fast path**: skip `group-by` allocation — use a direct key comparison over tokens and a linear scan over `prev-for-key`

Falls back to the original linear scan when `element-key-fn` is nil (no indexable equalities found).

....
  Before:
    for each token: scan all elements → O(T × E)

  After:
    build index: elements grouped by element-key-fn → O(E)
    for each token: lookup by token-key-fn → O(T + E) total
....

This is the primary driver of the large speedups observed in negation-with-join benchmark scenarios (scenarios 22–28).

=== 3.1 — Lazy/Demand-Driven Evaluation (PHREAK-Inspired)

**Files:** `engine.cljc`, `compiler.clj`, `macros.clj` | **Impact:** Avoids O(|A|) token allocations when condition A has many matching facts but condition B has none yet

Classic Rete eagerly propagates every change through the entire network.
The PHREAK algorithm (used in Drools) instead propagates lazily — nodes only evaluate when downstream demand exists (i.e., a production node could potentially fire).

....
  Eager Rete:
    RootJoinNode receives fact → immediately create tokens → send to all HashJoinNode children
    (even when children have no facts to join against yet)

  Demand-pull (implemented):
    RootJoinNode receives fact → defer token creation when ALL HashJoinNode children have
    empty alpha-memory → store only the element
    HashJoinNode receives first fact → demand-pull parent elements → create tokens on-demand
....

**Implementation:**

The optimization operates at the `RootJoinNode` → `HashJoinNode` boundary:

* `RootJoinNode.right-activate`: if *all* children are `HashJoinNode`s with `:left-parent-id` set (demand-pull eligible) AND *none* have any alpha-elements yet, skip `send-tokens`. Elements are still stored via `add-elements!`.
* `HashJoinNode.right-activate`: when no tokens exist in beta-memory and `:left-parent-id` is set, demand-pull tokens from the parent `RootJoinNode`'s alpha-memory. Elements are filtered to match the current `join-bindings` and tokens are generated and stored for future activations.
* `compiler.clj`: computes `:left-parent-id` for each non-root join node whose single parent is a `RootJoinNode`. Passed to `->HashJoinNode` only (not `ExpressionJoinNode`, which has more complex sub-indexing semantics).

**Benefit:** Avoids creating O(|A|) tokens in the beta network when condition A has many matching facts but condition B (which A must join with) has none. Tokens are generated lazily only when there is something to join against.

**Scope:** Limited to direct `RootJoinNode` → `HashJoinNode` edges. Recursive demand-pull and `ExpressionJoinNode` demand-pull are deferred to future work.

== Proposed Optimizations

=== 3.2 — Incremental Truth Maintenance via Delta Propagation

**Phase:** 3

Currently, when a logical insertion is invalidated, the engine retracts the fact and re-evaluates downstream from scratch.
Delta propagation would instead compute the _difference_ between old and new states and propagate only the delta.

....
  Current retraction cascade:
    rule invalidated → retract all logical facts → re-derive from scratch

  Delta propagation:
    rule invalidated → compute Δ(old-facts, new-facts) → propagate only changes
....

**Expected benefit:** Reduces redundant work when a rule's match set changes slightly (e.g., one of many matching facts is retracted, but the accumulated result is unchanged).

**Design notes (from implementation investigation):**

A naïve engine-level approach — caching TMS retractions in a per-`fire-rules*` volatile and cancelling them against subsequent logical re-insertions of the same fact — was prototyped and reverted due to a fundamental correctness violation.
The problem: `ProductionNode.left-retract` fires during `flush-updates` (between activations).
Deferring the resulting retraction into a cache means it is not yet reflected in the alpha network.
Any activation that fires before the cache is drained can therefore observe stale facts (e.g. an accumulator rule sees a fact that has logically been invalidated but whose alpha-retraction has not yet propagated).

....
  Broken: per-fire-rules* retraction cache

    Activation A fires → RHS retracts F1 → flush-rhs-retractions! → alpha-retract F1
      → ProductionNode(rule-B).left-retract → Cold queued in retraction cache (not yet in pending-updates)
    Activation C fires (accumulator rule) → observes Cold still in the network → WRONG result
    Activation B fires with new token → flush-insertions!(Cold) → cache hit → "cancels" retraction
    flush-tms-retractions!() → nothing to drain
    BUT: Activation C already fired with stale state → incorrect final result
....

The correct approach must operate at the **`AccumulateNode` level**, not the general engine level:

* When an accumulator's input set changes by adding or removing one fact, apply `retract-fn` + `reduce-fn` incrementally instead of retracting the old result and re-accumulating from scratch.
* This is safe because the accumulate node owns its own result state and can guarantee that the new result is available to downstream nodes before any activation fires.
* `CancellingUpdateCache` (already available via `{:cancelling true}` in `fire-rules`) handles cancellation of equal insertions and retractions at the `pending-updates` level, but is CLJ-only and requires opt-in. Making it the default or extending it to CLJS is a lower-effort partial improvement.

**Pre-requisites / considerations:**

* Accumulators must expose an incremental update path; current `Accumulator` record has `retract-fn` and `reduce-fn` but no explicit delta API.
* Correctness of negation and join nodes downstream of the accumulate result must be preserved.
* The `{:cancelling true}` mode already solves the symmetric insert+retract case for unconditional facts; the TMS case is harder because the retraction token and the re-insertion token differ.

== Optimization Summary

[cols="1,3,2,1"]
|===
|ID |Optimization |File(s) |Status

|1.1
|`drop-one-of` vector optimization
|`accumulators.cljc`
|✓ Done

|1.2
|`do-accumulate` 3-arity
|`engine.cljc`
|✓ Done

|1.3
|Listener null-check short-circuit
|`engine.cljc`
|✓ Done

|2.1
|Join node unlinking
|`engine.cljc`
|✓ Done

|2.2
|Alpha discrimination tree
|`compiler.clj`, `engine.cljc`
|✓ Done

|2.3
|OrderedUpdateCache mutable collections
|`update_cache/core.cljc`
|✓ Done

|2.4
|Beta sub-indexing for ExpressionJoinNode
|`compiler.clj`, `engine.cljc`
|✓ Done

|2.5
|FusedAlphaNode batched alpha dispatch
|`rules.cljc`, `compiler.clj`, `engine.cljc`
|✓ Done

|2.6
|Allocation reduction in engine hot paths
|`engine.cljc`, `memory.cljc`, `platform.cljc`
|✓ Done

|2.7
|Collection-oriented batch joins (match-pair hoisting, single-item fast paths, RootJoinNode mapv, propagate-items-to-nodes fast path)
|`engine.cljc`
|✓ Done

|2.8
|`NegationWithJoinFilterNode` sub-indexing: O(T×E) → O(T+E) for `:not` conditions with join filters
|`compiler.clj`, `engine.cljc`
|✓ Done

|3.1
|Demand-pull token generation (PHREAK-inspired): defer `RootJoinNode` → `HashJoinNode` token creation until elements arrive
|`engine.cljc`, `compiler.clj`, `macros.clj`
|✓ Done

|3.2
|Incremental truth maintenance (delta propagation)
|`engine.cljc`, `memory.cljc`
|Proposed
|===
